---
layout: post
title:  "[C++] 배열, 포인터. 구조체"
summary: "배열,포인터, 구조체"
author: moon
date: '2021-05-23 12:35:23 +0900'
category: cpp
thumbnail: /assets/img/posts/bitoper.PNG
keywords: cpp, basic, for, while, function
permalink: /blog/cpp/pointer/
usemathjax: true
---

### 포인터

---

- 정의
    - 메모리상의 주소를 말하며 이러한 포인터를 가진 변수를 포인터 변수라한다.
- 선언
    - *(포인터 연산자)를 자료형 뒤에 선언하면 포인터 변수가 된다.
    - &(참조 연산자)를 변수명 앞에 선언하면 변수의 주소값을 가져온다.
    - (자료형)* 변수명 = 초기값

        ```cpp
        int i = 100;
        //아무주소도 가르키지 않을때 이용
        int * print= nullptr;

        //i의 주소를 할당
        print = &i;
        //주소를 참조하여 i의 값을 변경
        (*print) = 100;

        float f= 3.f;

        print = (int)&f;
        //주소위치에 값을 대입
        (*print) = 100;
        ```

    - 포인터에서 사용되는 주소의 단위는 byte(바이트)이다. 비트단위로는 표기 불가능
    - 자료형을 정의하는 이유는 자신이 가질 주소의 타입을 이미 정해놓은것(주소가 접근해서 가져야할 값을 알려줌)
    - 포인터변수의 크기는 모두 같다
        - Why?
            - 포인터는 결국 주소를 저장하는 변수이고, 어떠한 자료형이든 주소의형태는 모두 같기 때문에 크기가 같다.
        - 크기는 어떻게 아는가?
            - 플랫폼에 따라 다르다 ex) 32bit, 64bit 운영체제
            - 32bit면 4byte, 64bit면 8byte에 해당한다.
            - 32bit는 42억개의 주소를 가질 수 있다 (메모리로 환산하면 4GB)
            - 64bit는 한동안은 메모리 걱정할 필요가 없다 (42억*42억개만큼 주소를 가질수 있음)
    - 포인터의 연산은 일반 산수 연산과는 다르다
        - 포인터의 크기를 1만큼 증가시킨다 → 다음 포인터를 가르킨다.
            - 포인터가 int형을 가르키는 주소라면 다음 주소를 가르키기위해 4만큼 주소가 증가
            - 즉 포인터가 해석하는 자료형의 크기만큼 증가한다고 할 수 있음
    - 포인터와 const 키워드
        - const 키워드 ⇒ java의 final 역할

            ```cpp
            //상수선언
            //r-value
            //l-value <=변수
            //상수는 변경이 불가능 즉 한번 선언후 대입이 안된다.
            //근데 포인터를 이용하면 값을 바꿀 수 있다.
            const int cInt = 100;
            	int *pInt = (int*)&cInt;
            *pInt = 300;
            printf(cInt)
            ```

        - 이럴 경우 cInt이 나와야 하나 visualStudio에선 100이 나온다.
            - const 선언시 상수이기 때문에 별도의 공간에 상수값을 저장
            - 그 이후 상수 호출시 해당 공간의 값을 불러옴(상수변수의 메모리가 아님)
            - 그렇기 때문에 100이나온다.
            - 이러한 현상을 피하고 싶으면 volatile을 선언하면 우리가 의도한대로 움직인다.
            - 즉 const가 절대적으로 상수값을 보호해주지 않는다
        - const+ pointer변수

            ```cpp
            const int * pConstInt = &a;
            //불가능
            *pConstInt = 100;
            //가능
            pConstInt = &b;
            ```

            - 포인터 변수에 const를 선언하면 주소가 가리키고 있는 값을 수정할 수 없음
            - 하지만 포인터변수가 가질 주소를 바꾸는건 가능
        - 포인터 + const

            ```cpp
            int* const pIntConst = &a;
            //가능
            *pConstInt = 100;
            //불가능
            pConstInt = &b;
            ```

            - 주소가 가리키고 있는 값을 수정할 수 있음
            - 주소자체를 변경하는건 불가능
        - const 포인터 const

            ```cpp
            const int * const pConstIntConst = nullptr;
            ```

            - 주소와 값모두의 변경을 금지하는 방법
            - 초기화시에 설정한 대상만 가리킴
        - 왜 사용할까?
            - 함수에서 파라미터로 넘겨줄때 어떤부분에 대한 쓰기를 제한시키기 위해서
            - 주소를 넘겨받게 되면, 원본을 고칠 수 있음
            - 원본을 고치지 못하게 하거나, 주소를 고치지 못하게 하기위해 사용(읽기전용 개념)
- void  포인터
    - 특정한 자료형을 지정하지 않은 포인터(포인터라면 모두 받을수 있음)
    - 역참조 불가능(원본의 자료형이 정해져 있지 않기 때문에)
    - 주소연산 불가능(원본 자료형이 정해져 있지 않기 때문에)

## 배열

---

- 많은 수의 변수를 하나의 변수로 통제하기 위해 사용하는 방법

    ```cpp
    //int 변수 10개를 일일이 선언하여 관리하면 힘들다
    int i =0;
    int ii= 0;
    ---
    int iii...iii =0;

    //배열
    int iArray[10] = {};
    ```

- 배열의 값에 접근 방법
    - 인덱스를 선택하여 접근한다.
    - 배열의 크기가 10이라면 인덱스는 0~9까지 할당된다.

        ```cpp
        int iArray[10] = {};
        //1번째 인덱스
        iArray[0] = 10;

        //인덱스 범위밖 (크키가 할당되어있지 않은 Un-Safe하기 때문에 이용할수 없음)
        //메모리가 할당되어있으면 오류도 안잡힘(이래서 STL을 쓰는거다)
        //디버그시 에러를 잡아주나, Realse시에는 안잡힘으로 매우 신경써줘야함
        iArray[10] = 10;
        ```

- 배열의 특징
    1. 메모리가 연속적인 구조이다.
    2. 배열의 이름은 배열의 시작 주소이다.

        ```cpp
        int iArr[10] = {};

        //가르키는 주소값에 값을 대입(시작주소 다음주소니 1번인덱스에 값을 대입)
        *(iArr+0) = 10; //iArr[0] = 10; 배열의 인덱스 시작이 0인이유
        *(iArr+1) = 10; //이것의 축약형 iArr[1] =10;

        ```

## 구조체

---

- 의미
    - 사용자가 정의한 자료형

        ```cpp
        //구조체의 선언(C 언어 선언방법)
        //typedef struct (구조체이름)
        typedef struct _tagMyST
        {
        	int a;
        	float f;
        } MYST;//=>리넴임(이것으로 호출한다);

        //구조체 선언 (C++)

        struct _tageMyST
        {
        	int a;
        	float f;	
        };
        ```

    - 구조체에서 typedef 키워드는 타입재정의를 의미한다.(기본 타입들에 대한 재정의도 가능)
    - C언어에서는 struct를 명시해야만 구조체로 인식하기 때문에 typedef를 사용해서 이름을 재정의한다.
    - C++에도 C언어 방법이 남아있는 이유는 C언어와의 호환때문에 남아있다.
- 구조체 이용방법

    ```cpp
    struct _tageMyST
    {
    	int a;
    	float f;	
    };

    int main()
    {
    	//배열처럼 선언된 순서에 따라 괄호를 이용해 초기화가능
    	 _tagBMyST f = { 1,2 };
    	//.(닷)을 이용하여 구조체 내부의 데이터에 접근가능
    	f.a = 10;
    	f.f = 20;
    }

    // 원래 함수를 추가하거나 생성자를 추가하는등의 과정도 가능하지만 그건 나중에 할 예정
    ```