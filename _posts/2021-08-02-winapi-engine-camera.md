---
layout: post
title:  "[C++][WinAPI] Create Game Engine -11 Camera"
summary: "winapi game engine"
author: moon
date: '2021-08-02 12:35:23 +0900'
category: WinAPI
thumbnail: /assets/img/posts/bitoper.PNG
keywords: cpp, oop, winapi, ui, grapic,engine
permalink: /blog/cpp/winapi/engine/camera
usemathjax: true
---
## 카메라가 필요한 이유

---

- 게임을 더 동적으로 만들기 위한 목적이다.
- 현실 세계에서 보는 풍경을 한번에 다 볼 수 없든 게임속 세상도 똑같다.
- 이러한 부분을 표현하기 위해 사용자가 바로보는 시야를 카메라로서 구현한다.

## 카메라와 위치

---

- 현재는 고정된 화면에서 게임을 그리기 때문에 출력위치 와 오브젝트의 위치가 같다
- 하지만 카메라를 이용하게 되면, 카메라가 보고 있는 위치(게임내 위치) 와 출력되는 위치가 달라진다.
- 왜냐하면 카메라가 출력되는 화면도 좌표고, 오브젝트가 어딘가에 위치하고 있는 것도 좌표이기 때문이다.
- 즉 이러한 차이를 메꾸기 위한 변환작업이 필요하다. 예를 들어 어떤 물체를 보고 있을때 카메라가 좌측으로 움직이면 그 물체의 실제위치는 고정되어있지만, 마치 오른쪽으로 움직이는것 처럼 카메라에 그려져야한다.

## 위치차이 계산

---

- 카메라는 타겟의 중 이나 화면 정중앙을 비추고 있다.
- 즉 어떤 물체를 봐라볼때도 그 물체의 중앙을 기준으로 보게 되는데 그때 카메라가 이동하게되면 주변물체의 거리의 차이만큼 위치를 뺴주게된다.
- 이 차이로 계산된 위치가 렌더링 좌표이며, 앞으로 모든 렌더링과 관련된 좌표는 이 좌표를 사용한뎐된다.

```cpp
void CCamera::CalDiff()
{
	Vec2 vResolution = CCore::GetInst()->GetResolution();
	Vec2 vCenter = vResolution / 2;

	m_vDiff = m_vLookAt - vCenter;
}
```

## 부드럽게 따라가기(Smooth  Follow)

---

- 갑자기 화면전환을 하게 되었을때 카메라가 순식간에 바뀌는게 아닌 부드럽게 이동하여 전환되는 기능

### 마우스 위치 얻기

---

GetCusorPos라는 함수를 이용하면 현재 마우스 위치를 알수 있는데, 문제는 화면 전체(내 모니터) 전체의 좌표를 기준으로 가져온다.

이를 위해 마우스 좌표를 현재 창기준으로 바꿔주는 함수를 사용하여 실제 위치를 계산해줘야한다.

ScreenToClient함수를 이용하면 마우스의 위치를 얻을 수 있다.

```cpp
		POINT pt = {};
		//윈도우 전체(컴퓨터 화면기준)에서 좌표를 가져옴
		GetCursorPos(&pt);
		//윈도우 기준에서 현재 게임클라이언트 기준으로 좌표를 바꾸어줌
		ScreenToClient(CCore::GetInst()->GetMainHwnd(), &pt);

		m_vCurMousePos = Vec2((float)pt.x, (float)pt.y);
```

### 마우스의 위치에 따라 좌표변경

---

- 마우스의 클릭을통해 카메라화면을 이동시킨다고 하면, 마우스 좌표를 카메라가 보고 있는 좌표로 설정해서는 원하는 대로 움직이지 않는다.
- 그 좌표는 출력용(카메라 내의 좌표)이기 때문에 실제 게임내에 위치를 계산해서 그곳을 카메라에게 넘겨줘야한다.

### 위치 보정하기

---

- 보정을 위해서는 총 3개의 좌표가 필요하다 , 이전 프레임의 보는 위치, 진짜 보는위치, 보정한 위치
- 진짜 보는위치가 아닌 현재 보정한 위치를 앞으로 계산을해서 사용을 하며 이 위치를 기준으로 모든 렌더링이 계산된다.
- 위치 계산하기
    1. 현재 위치와 이전 위치의 벡터를 빼서, 방향벡터를 구한다(노멀라이즈 필수!)
    2. 이제 이전 좌표에  방향벡터에 지정해준 속력(이동시간을 지정하고, 두 점사이의 거리를 구해 속력을 구하면된다)만큼 곱하고, delta time도 곱해준 값을 더해준다.
    3. 이 결과로 나온 좌표가 현재좌표가 된다.
    4. 이 좌표를 계속 업데이트하고 출력하고 업데이트하고 출력하고 반복을 해서 , 실제 보는 좌표에 도달하면 멈춘다.

## 부드럽게 움직이기 1차

---

```cpp
// 이전 LookAt 과 현재 Look 의 차이값을 보정해서 현재의 LookAt 을 구한다.
	m_fAccTime += fDT;

	if (m_fAccTime > m_fMoveTime)
	{
		m_vCurLookAt = m_vLookAt;
	}
	else 
	{
		Vec2 vLookDir = m_vLookAt - m_vPrevLookAt;
		m_vCurLookAt = m_vPrevLookAt + vLookDir.Normalize() * m_fSpeed * fDT;
	}
	
	Vec2 vResolution = CCore::GetInst()->GetResolution();
	Vec2 vCenter = vResolution / 2;	
	
	m_vDiff = m_vCurLookAt - vCenter;
	m_vPrevLookAt = m_vCurLookAt;
```

## 렌더링 범위설정하기

---

- 만약 게임내에 오브젝트를 한번에 렌더링할경우, 컴퓨터 성능이 감당할 수 없게된다.
    - 실제 10000개의 타일만 렌더링해도 프레임이 30밑으로떨어져 실질적인 게임이 불가능하다
    - 화면에 들어오는건 200개의 타일일뿐이라도 나머지 99800개의 렌더함수가 호출되기 때문에 속도가 매우저하된다.
- 이를 위해서 카메라 영역에 들어오는 타일만 찾아서 해당 타일만 렌더링을 해줘야한다.
    1. 현재 카메라가 보고있는 실제좌표를 구한다.
    2. 카메라가 표시하는 해상도를 알고있다.
    3. 좌상단 좌표는 실제좌표에서 해상도좌표만큼 빼버리고 2를 나누면된다.
    4. 해당 좌상단좌표에 해당하는 타일의 행과열을 구한다.
    5. 이제 카메라 표시영역 가로길이에 타일이 얼만큼 들어가는지 구한다. 마찬가지로 세로길이도 구한다.
        1. 인덱스가 음수로 넘어가는 타일이 생길수도 있다(제일 좌상단으로 갔을때)
        2. 이를 방지하기 위해 
            1. 현재열이 0보다 작거나 
            2. 나타낼 가로길의 타일개수보다 크거나, 
            3. 행이 0보다 작거나
            4. 나타낼 최대의 개수를 행이 초과했을때
        3. 이 4가지를 예외처리해서 contitnue를 한다.
    6. 이제 반복문을 돌면서 타일들의 인덱스를 구해, 해당 인덱스를 구한다. 

- 더 최적화하는 방법
    - 미리 거대한 맵을 제작해서 텍스쳐를 저장해놓고, 카메라의 위치에따라 해당영역의 좌표를 구해 bitblt한번으로 렌더링해버리면 끝난다.