---
layout: post
title:  "[C++][WinAPI] Create Game Engine -14 Game UI"
summary: "winapi game engine"
author: moon
date: '2021-08-05 12:35:23 +0900'
category: WinAPI
thumbnail: /assets/img/posts/bitoper.PNG
keywords: cpp, oop, winapi, ui, grapic,engine
permalink: /blog/cpp/winapi/engine/gameUI
usemathjax: true
---
## UI Object 설계하기

---

### UI 기본기능

---

- UI도 게임내 오브젝트이기 때문에 CObject를 상속 받아 구현한다.
- 렌더링은 좌상단 좌표를 기준으로 우측하단으로 이미지를 확대해 나가는 식으로 그림을 그린다.
- UI는  가장 외곽에 표시하도록 그룹타입을 마지막으로 지정한다.
- UI는 계층구조로 구성되며 씬에는 최상위 UI만 넣어준다.
    - 이 방식의 경우 UI의 업데이트 순서, 렌더링순서가 자동으로 정해진다(무조건 부모에서 자식을 업데이트 해주고 렌더링 해줘야한다)
- UI는 finalupdate를 수행하여 자신의 최종위치를 결정해야한다. 왜냐하면 부모를 기준으로 상대적 위치인 오프셋과 최종위치 2개를 가지고 있기 때문이다.
- 부모가 없으면 자신의 위치가 곧 최종위치이다
- 부모가 사라질때 자식들을 소멸시켜줘야한다.

### UI 이벤트 처리

---

- 모든 UI에대해 이벤트 처리를 하는게 아닌, 필요한 이벤트에만 함수를 구현하도록 구현
- 마우스 클릭, 마우스 온, 마우스 드래그 등등을 각각 다른 함수로 나누어 필요한 기능만 구현한다.
- 현재 대부분의 UI는 설계가 같은 범위내에서(UI 크기내)에서 업 다운이 일어날때 클릭이라고 한다.
- 그렇기 때문에 업 다운 이벤트를 구분해야한다.
- 이벤트 구현은 UI내에서 하고 처리는 UI 매니저를 통해 관리한다.

### UI 매니저

---

- 이벤트에 대한 처리를 담당하며, 어떤 UI에 이벤트가 들어가야하는지 그 시점을 알려준다.
- UI의 업데이트 시점은 렌더링 바로 이전에 이루어지면 된다.

### UI 마우스 이벤트

---

- UI가 카메라에 영향을 받는지 안받는지에 따라 마우스에 대한 좌표가 달라진다.
- 따라서 UI를 생성할때 애초에 영향을 받는지 안 받는지를 지정하고 이를 체크하는 함수를 만들어둔뒤 체크 결과를 매니저에서 호출할 수 있도록한다.

     

    ### 부모와 자식 UI 이벤트 처리

    ---

    - 일반적으로 자식 UI를 클릭했을때 부모에게 이벤트를 발생시키지 않는다.
    - 현재 최상위 부모한테만 접근해서 이벤트를 잡기 때문에 자식들까지 체크할 수 있는 이벤트 처리 함수를 생성해야한다.

         

        ```cpp
        CUI* GetTargeteUI(CUI* _pParentUI)
        {
        	//부모 UI를 받아 현재 마우스가 타겟하고 있는 UI를 반환한다.
        	//1. 마우스 위치에 있는 부모 UI를 포함하여 모든 자식을 검사한다
        	CUI* pTargetUI = nullptr;
        	//2. level순회를 통해 찾는다(queue 활용)
        	//3. 각 층 별로 모든 노드를 queue에 집어넣고, dequeue할때 노드를 검사한다. 
        	//4. 검사를 한후 자식들을 다시 queue에 집어넣는다.
        	//5. 타겟 UI 들 중, 더 우선순위가 높은 기준은 더 낮은 계층
        	return pTargetUI;
        }
        ```

### 부모 UI간의 포커스 찾기

---

1. 마우스로 창 드래그 하기
    - panel ui의 경우 대부분 드래그를 하여 창을 이동하는 방식을 지원을한다.
    - 이를 구현하기 위해서는 판넬에서 마우스로 본인을 누르고 있는지 체크해야한다.
    - 본인을 누르기 시작할때 위치를 기억해 현재 마우스위치와 차이로 방향을 구한다.
    - 이후 현재 위치에 그 차이를 더하고 현재 위치를 드래그 시작점으로 옮긴다.

    ```cpp
    Vec2 diff = MOUSE_POS - dragStartMousePos

    current += diff;
    SetPos(vCurPos)
    dragStartMousePos = MOUSE_POS
    ```

2. UI 클래스 복사 생성자 수정
    - 현재 최상위 복사 생성자를 이용해 복사하면 부모가 같고 자식도 같은 그런 현상이 나타나기 때문에 깊은 복사로 수정이 필요하다.
    - 복사한 객체가 기존 객체와 다르게 설정하도록 바꿔줘야한다.
    - 유저 생성한 생성자를 선언할때 부모의 복사생성자를 호출하도록 명시해줘야한다.
3. UI 포커스 지정
    - 복사한 UI를 겹처두고 위에 위치한 UI를 클릭하면 밑에 있는 UI도 같이 클릭이 된다.
    - 이를 방지하기 위해 매니저에서 현재 포커스를 받고있는 UI를 관리한다.
    - 포커싱한 UI를 찾아, 그 UI에 대해서만 이벤트를 처리해주면된다.

    ### Focus UI 가져오기

    ---

    1. 만약 포커싱중인 UI가 계속 진행중이라면, 원래 UI를 반환해준다.
    2. 포커싱이 바뀔때는 왼쪽클릭으로 창을 클릭했을때이다.
    3. 포커싱이 바뀌게 되면 포커싱이 된 순서대로 창의 렌더링이 정렬되는데, 최근일수록 제일 늦게 렌더링이 된다.
        1. 이를 구현하기 위해서는 두가지 방법이 있다.
            1. UI 오브젝트의 그룹을 받아와서 렌더링 순서를 변경하는 법
            2. Scene매니저에서 렌더링 순서를 조절할 수 있는 함수를 만드는법
    4. 포커싱을 찾을 때 주의할점은 바로 UI가 겹쳐있을때
        1. 겹쳐있는 부분을 클릭했을때 렌더링 순서가 먼저 위치한 뒤에 있는 UI가 자신이 Focus라고 말할 수 있기 때문에 마지막까지 UI를 모두 체크한뒤 focusui를 결정해준다.
    5. 그다음 왼쪽 버튼이 눌렸을때 마우스가 UI위에 있다면 FocusUI로 설정한다.(이때 반복자를 사용하면 훨씬 편하다)

## 버튼의 이벤트 처리

---

- 현재 구조상 새 기능을구현하기위해서는 클래스를 새로 설계해야한다
- 왜냐하면 클릭이벤트처리가 어떠한 파라미터를 받지 않도록 설계되었기 떼문
- 이를 해결하기 위해 UI내에 이벤트를 담당할 함수 포인터를 타입으로 선언을 한다.

    ```cpp
    typedef void(*BNT_FUNC) (DWORD_PTR,DWORD_PTR);

    //클래스 내부
    private:

    BNT_FUNC m_ptrFunc;
    DWORD_PTR m_param1;
    DWORD_PTR m_param2;
    ```

    - 함수의 인자들도 저장해야하기때문에 인자에 대한 변수도 같이 선언해준다.
    - 그후 해당 함수를 받아 변수에 저장한뒤 콜백함수를 세팅해준다
    - 마지막으로 콜백함수가 존재할때 클릭시 실행을 시킨다

## 버튼이벤트로 멤버함수호출하기

---

- 멤버함수는 객체가 있어야 호출 할수 있기 때문에 기존의 함수 포인터를 호출하는 방법과는 다르다.

```cpp
typedef void(CScene_Tool::*TOOL_SCENE_MEMFUNC)(void);
```

- 위와 같은 함수를 선언하게 되면, 필요한 멤버함수가 생길때마다 함수포인터를 새로 설정해야한다.
- 이는 매우 비효율적인 구조이다. 원래는 이러한 문제를 방지하기 위해 **프레임워크내 모든 클래스의 최상위 부모클래스를 통일한다음 파생시키는게 제일좋다.**
- 현재는 그러한구조로 설정이 되어있지 않으므로 필요한 부모클래스를 모두 설정해주는게 좋다.

    ```cpp
    //상속관계라면 부모클래스로 자식의 함수포인터까지 커버 가능
    typedef void(CScene::*SCENE_MEMFUNC)(void);

    //클래스내의 멤버함수를 부를 객체도 필요하다.
    CScene* m_pSceneInst;
    ```

- 이벤트함수를 불러왔다면 실제 함수를 호출해야하는데, 이 방법이 조금 복잡하다

    ```cpp
    if(m_pSceneInst && m_pSceneFunc)
    {
    	//포인터 역참조로 원형들로 불러줘야한다
    	((*m_pSceneInst).*m_pSceneFunc)();
    }

    ```

- 이벤트 함수를 설정하는건 이렇게 해야한다.

    ```cpp
    SetClickedCallBack(this,(SCENE_MEMFUNC)&CScene_Tool::SaveData);
    ```

- 멤버함수 포인터를 이용할때는 정확한 정보를 알아야한다. 즉 헤더를 include해야만 사용가능하다, 그렇기 때문에 처음 설계할때 꼭꼭 최상위 부모클래스에서 파생하는 구조로 만들어야한다.