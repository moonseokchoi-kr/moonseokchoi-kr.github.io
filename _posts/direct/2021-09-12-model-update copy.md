---
layout: post
title:  "[C++][Direct2D] Create Game Engine -5 Entity, Resource"
summary: "Direct2D game engine"
author: moon
date: '2021-09-12 12:35:23 +0900'
category: Direct2D
thumbnail: /assets/img/posts/bitoper.PNG
keywords: cpp, oop, Direct2D, ui, grapic,engine
permalink: /blog/cpp/Direct2D/engine/entity-resource
usemathjax: true
---
## 최상위 부모 클래스 설계하기

---

- [Entity Component System](https://m.blog.naver.com/dlwhdgur20/221012364253)(ECS)기반 아키텍처로 설계되어지기 때문에 최상위 클래스인 Entity를 생성하여 이 클래스로 부터 모든 기능이 파생되어 만들어진다(singleton 클래스 제외)

## Resource

---

- Direct에선 정점들도 공유를 할 수 있기 때문에 리소스로 구분되어진다.
- 이러한 데이터를 Mesh라 부른다.
- Resource는 공유되어지기 때문에 함부로 메모리에서 삭제를 할 수 가 없다.
- 따라서 Reference Count를 통해 0보다 클경우 메모리에서 삭제되지 않도록 해야한다.
- 설계시 주의 할점
    - 전체 화면모드 에서 Alt+Tap(화면전환)을 할시 크러시가 날 문제가 있다.
        - 이를 방지하기 위해, System memory에서 GPU에 넣어준 데이터들을 보관하고 있는게 안전한다.
    - 전체 창모드 지원으로 해결할 수 있지만, 전체 창모드는 전체화면에 느리다는 단점이 있다.
    

### Mesh

---

- Direct에서는 물체의 정보와 정점의 데이터도 리소스로 활용이 가능하다.

```cpp
void Create(VTX* _pVtx, UINT _iVtxCount, UINT* _pidx, UINT _idxCount)
{
	//어떤 물체를 만들기위한 정점버퍼 생성, 
	//그리는 순서를 정한 인덱스 버퍼를 생성
}
```

- 메쉬를 생성하는 작업은 이전에 정점버와 인덱스 버퍼를 만드는 과정과 동일하다
- Mesh클래스에서 화면전환등을 위한 다시 그리기를 위해 정점데이터와 개수, 인덱스데이터와 개수를 기억하고 있는게좋다.
    
    ```cpp
    //이렇게 지정하면 안된다. 지역변수이기 때문에 의미가 없다.
    m_pIdxSys = _pIdx;
    m_pVtxSys = _pVtx;
    
    //메모리 내용을 복사하는 memcpy를 통해 복사해야한다.
    ```
    

### Shader

---

- 정점에 대해서 정리하는 과정을 다 하고 셰이더에 대한 구조를 잡아야한다.
- 파이프라인을 보면 정점, 공간, 지오메트리 테셀레이션 레스터라이저 픽셀셰이더, OM단계까지 다양한 셰이더 단게가 있고 필수인 셰이더도 있으며 옵션인 셰이더도 있다..
- 이러한 구조를 파이프라인 스테이트 라 하고 앞으로 셰이더라고 부른다
- 이러한 셰이더의 종류는 여러가지가 될 수 있다.(엔진에서 말하는 셰이더 그래프를 이런식으로 구성하는것 같다)
- 셰이더도 다른물체에 공유될수 있기 때문에 리소스다 (같은 방법으로 렌더링하는 셰이더를 여러개 만들 필요없이 그 셰이더에 통과시켜 주면 된다.)
- 프로그래밍 가능한 셰이더들은 hlsl코드를 저장할 blob과 shader클래스가 쌍으로 존재를 해야한다.
- 셰이더를 쓰든 안쓰든 무조건 업데이트를 해야한다. 그래야만 자신이 원하는대로 적용받을 수있다.(안쓰는걸 업데이트 안하면 이전셰이더가 그대로 적용
- 레이아웃
    - vertexlayout은 여러 셰이더에서 공유를 하여 사용되며, 한번선언을 하면 그 내용이 모든 버텍스에 영향을 미치기 때문에 extern변수로 선언을해서 엔진 어디에서나 사용할 수 있어야한다.
    - 대신 정점 구조체에 새로운 값을 추가할때마다 레이아웃을 변경해줘야한다.
    - 레이아웃을 생성할땐 버텍스 버퍼에 대한 정보도 필요하기 때문에 버텍스버퍼 생성후 레이아웃을 만들어주어야한다.
    - 버텍스셰이더, 레이아웃, 버텍스는 서로 연결되어있기 때문에  사용할때 매칭을 잘해줘야한다.

### ConstantBuffer

---

- 상수버퍼는 디바이스에서 관리를 한다,
- 상수버퍼를 의마하는 클래스를 구성하고, 상수버퍼를 만들기 위한 멤버들을 작성한다.
- 상수버퍼에서 해야할 예외처리를 한가지 해야한다. 상수버퍼에 저장할 데이터가 상수버퍼크기보다 크면 오류가 발생하기 때문에 강제로 에러를 발생시켜야한다.
- 상수버퍼는 모든 셰이더에서 사용이 가능하고, 상수레지스터는 여러개 존재하므로 어떤 셰이더에서 정보를 업데이트하고 몇번 레지스터를 사용할건지 에대해 설정할 수 있어야한다.
- 레지스터는 역할에 따라 번호를 정하도록 설계를 하면 간단하게 업데이트 처리가 가능하기 때문에 이런 방법으로 설계하는게 좋다.
- 위의 방법으로 생성을 할때부터 레지스터의 번호를 지정하면 해결된다.
- 상수버퍼를 리소스에서 관리하지 않는 이유
    - 상수버퍼는 사용할 목적만큼만 생성하고 셰이더에서만 사용되기 때문에 다른 리소스들과 성격이 다르다.
    - 따라서 Device클래스에서 Enum을 통해 관리하는것이 효율적이다.